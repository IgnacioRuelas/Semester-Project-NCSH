# -*- coding: utf-8 -*-
"""ScriptDashboardIgnacioRuelas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Lxx8FdO_KTGdbHysPw8-rXRAHwiHnZ3j
"""

#pageOne
import pandas as pd
import streamlit as st
st.write("Please use the tabs to navigate the dashboard.")

df = pd.read_csv('NHS_Data.csv')

approved_df = df[df["Request Status"] == "Approved"]

def clean_signed_status(val):
    if pd.isna(val) or str(val).strip().lower() in ["", "N/A"]:
      return "Missing"
    elif str(val).strip().lower() == "yes":
      return "Yes"
    elif str(val).strip().lower() == "YES":
      return "Yes"
    elif str(val).strip().lower() == "no":
      return "No"
    else:
      return "Missing"

approved_df["Application Signed Cleaned"] = approved_df["Application Signed?"].apply(clean_signed_status)

summary = approved_df["Application Signed Cleaned"].value_counts(dropna=False).reset_index()
summary.columns = ["Application Signed?", "Count"]
summary["Percentage"] = (summary["Count"] / summary["Count"].sum() * 100).round(2)
summary["Percentage"] = summary["Percentage"].apply(lambda x: f"{x:.1f}%")

display_df = approved_df[["Patient ID#", "Application Signed Cleaned"]].rename(
    columns={"Application Signed Cleaned": "Application Signed?"}
).reset_index(drop=True)

st.title("Approved Applications Page")
st.subheader("Summary of Application Signed Status")
st.table(summary)

st.subheader("Filter by Application Signed Status")
status_filter = st.selectbox("Select a status",["All", "Yes", "No", "Missing"])

if status_filter != "All":
  filtered_df = display_df[display_df["Application Signed?"] == status_filter]
else:
  filtered_df = display_df
st.subheader("Filtered Approved Applications")
st.dataframe(filtered_df, hide_index=True)

#pageTwo including gender, type of insurance and median household income
import altair as alt
import matplotlib.pyplot as plt


# Convert 'Amount' to string and replace special characters
approved_df["Amount"] = approved_df["Amount"].astype(str).str.replace(r"[$,]", "", regex=True)
approved_df["Amount"] = pd.to_numeric(approved_df["Amount"], errors="coerce")


#Fitering so the financial information breaksdown into locations

approved_df["Pt City"] = approved_df["Pt City"].astype(str).str.title()

#Fitering so the financial information breaksdown according to gender

approved_df["Gender"] = approved_df["Gender"].fillna("Missing").astype(str)
approved_df["Gender"] = approved_df["Gender"].str.title()
approved_df["Gender"] = approved_df["Gender"].where(approved_df["Gender"].isin(["Male", "Female"]), "Missing")

#Fitering so the financial information breaksdown according to Insurance

approved_df["Insurance Type"] = approved_df["Insurance Type"].astype(str).str.strip()
approved_df["Insurance Type"] = approved_df["Insurance Type"].replace({
    "Uninsurred":"Uninsured",
    "Unisured":"Uninsured",
    "MEdicare":"Medicare",
    "medicaid":"Medicaid",
    "Missing":"Missing",
    "missing":"Missing",
    "NA":"Missing",
    "N/A":"Missing",
    "Nan": "Missing",
    "nan": "Missing",
    "": "Missing"
})

approved_df["Insurance Type"] = approved_df["Insurance Type"].fillna("Missing")

#Median household income. This section is based on the median household income estimated by the Census Data
#So: one group is less than 833 monthly; the other is 833 < value <6,215; then value > 6,215

# Clean and categorize income
def categorize_income(val):
    try:
        income = float(str(val).replace(',', '').replace('$', '').strip())
        if income <= 833:
            return 'Low (≤ $833)'
        elif income <= 6215:
            return 'Middle ($834–$6,215)'
        else:
            return 'High (> $6,215)'
    except:
        return 'Missing'

approved_df['Income Category'] = approved_df['Total Household Gross Monthly Income'].apply(categorize_income)

def clean_amount(val):
    try:
        return float(str(val).replace(',', '').replace('$', '').strip())
    except:
        return 0.0

approved_df['Cleaned Amount'] = approved_df['Amount'].apply(clean_amount)

#Cleaining by Race

def clean_race(race):
    race_str = str(race).strip().lower()
    if not race or race_str in ["", "nan", "none", "missing"]:
        return "Missing"
    elif race_str == "whiate":
        return "White"
    elif race_str in [
        "american indian or alaksa native",
        "american indian or alaskan native"
    ]:
        return "American Indian or Alaska Native"
    else:
        return race.strip()

approved_df['Cleaned Race'] = approved_df['Race'].apply(clean_race)

# Group and sum amount by cleaned race
amount_by_race = approved_df.groupby('Cleaned Race')['Cleaned Amount'].sum().sort_values(ascending=False)

# Create DataFrame with totals and percentages by Race
total_amount = amount_by_race.sum()
race_df = amount_by_race.reset_index()
race_df.columns = ['Race', 'Total Amount']
race_df['Percentage'] = (race_df['Total Amount'] / total_amount * 100).round(1)

# Format as currency
race_df['Total Amount'] = race_df['Total Amount'].apply(lambda x: f"${x:,.2f}")
race_df['Percentage'] = race_df['Percentage'].astype(str) + '%'

#GROUPING DATA


# Count each category
income_counts = approved_df['Income Category'].value_counts().reindex(
    ['Low (≤ $833)', 'Middle ($834–$6,215)', 'High (> $6,215)', 'Missing'], fill_value=0
)

#Groping data according to cities

city_amount_summary = (
    approved_df.groupby("Pt City", dropna=False)["Amount"]
    .sum()
    .reset_index()
    .sort_values("Amount", ascending=False)
)

city_amount_display = city_amount_summary.copy()
city_amount_display["Amount"] = city_amount_display["Amount"].apply(lambda x: f"${x:,.2f}")


#Groping data according to gender, including percentages

gender_amount = (
    approved_df.groupby("Gender")["Amount"]
    .sum()
    .reset_index()
)

total_amount = gender_amount["Amount"].sum()
gender_amount["Percentage"] = (gender_amount["Amount"] / total_amount) * 100

gender_amount["Label"]= gender_amount.apply(lambda row: f"{row['Gender']}: {row['Percentage']:.1f}%", axis=1)

#Groping data according to top 10 cities
top10_cities = city_amount_summary.head(10)
top10_display = top10_cities.copy()
top10_display["Amount"] = top10_cities["Amount"].apply(lambda x: f"${x:,.2f}")

insurance_type_amount = (
    approved_df.groupby("Insurance Type")["Amount"]
    .sum()
    .reset_index()
)

#Groping data according to insurance type

total_amount = insurance_type_amount["Amount"].sum()
insurance_type_amount["Percentage"] = (insurance_type_amount["Amount"] / total_amount) * 100
insurance_display = insurance_type_amount.copy()
insurance_display["Amount"] = insurance_display["Amount"].apply(lambda x: f"${x:,.2f}")
insurance_display["Percentage"] = insurance_display["Percentage"].apply(lambda x: f"{x:.1f}%")

#Grouping by median household income

amount_by_category = approved_df.groupby('Income Category')['Cleaned Amount'].sum().reindex(
    ['Low (≤ $833)', 'Middle ($834–$6,215)', 'High (> $6,215)', 'Missing'], fill_value=0
)

# Grouping and sum amount by cleaned race
amount_by_race = approved_df.groupby('Cleaned Race')['Cleaned Amount'].sum().sort_values(ascending=False)


#st.write("Debug: Top 10 Cities DataFrame")
#st.write(top10_cities.columns)

#PLOTTING

#This page includes some figures for the daschboard
bar_chart = (
    alt.Chart(top10_cities)
    .mark_bar()
    .encode(
        y=alt.Y("Pt City:N", sort="-x", title="City"),
        x=alt.X("Amount:Q", title="Total Amount"),
        tooltip=["Pt City", "Amount"]
    )
    .properties(
        title="Top 10 Cities by Total Amount (Horizontal Bar Chart)",
        width=600,
        height=400
    )
)

pie_chart = (
    alt.Chart(gender_amount)
    .mark_arc(innerRadius=60)
    .encode(
        theta=alt.Theta(field="Amount", type="quantitative"),
        color=alt.Color("Gender", type="nominal"),
        tooltip=["Gender", "Amount", alt.Tooltip("Percentage", format=".1f")]
    )
    .properties(
        title="Gender Distribution",
        width=300,
        height=300
    )
)

#st.subheader("Top 10 Cities by Total Amount")
#st.dataframe(top10_cities)

#PREPARING INFO TO SHOW IN STREAMLIT

#Data Frames go first
st.title("Financial Overview")
st.subheader("Total Amount by Beneficiary City")
st.dataframe(city_amount_display)

st.subheader("Amount by Type of Insurance")
st.dataframe(insurance_display)

st.subheader('Total Amount and Percentage by Race')
st.dataframe(race_df)

#Now charts
st.subheader("Top 10 Cities by Total Amount - Bar Chart")
st.altair_chart(bar_chart, use_container_width=True)

st.subheader("Gender Distribution")
st.altair_chart(pie_chart, use_container_width=False)

st.subheader('Distribution by Household Monthly Income')
fig, ax = plt.subplots()
ax.pie(amount_by_category, labels=amount_by_category.index, autopct='%1.1f%%', startangle=90)
ax.axis('equal')
st.pyplot(fig)

#Page three on how long it takes between when the organization receives a patient request and actually send support. It consists of the difference between the date when the payment was mailed and the request date.

import plotly.express as px

#Using the shared CSV file

#CLEANING

approved_df["Payment Submitted?"] = approved_df["Payment Submitted?"].replace(
    {"Yes": None, "No": None}
)

# Ensure columns are numeric before converting to datetime
approved_df["Grant Req Date"] = pd.to_numeric(approved_df["Grant Req Date"], errors="coerce")
approved_df["Payment Submitted?"] = pd.to_numeric(approved_df["Payment Submitted?"], errors="coerce")

#convert to datetime

origin_date = pd.to_datetime("1899-12-30")
approved_df["Grant Req Date"] = origin_date + pd.to_timedelta(approved_df["Grant Req Date"], unit="D")
approved_df["Payment Submitted?"] = origin_date + pd.to_timedelta(approved_df["Payment Submitted?"], unit="D")


#Calculating time to make the support effective

approved_df["Days to Support"] = (approved_df["Payment Submitted?"] - approved_df["Grant Req Date"]).dt.days
# Convert to absolute value
approved_df["Days to Support"] = approved_df["Days to Support"].abs()


#Defining bins with a '0' group
bins = [-0.1, 0, 7, 14, 30, 60, 90, 180, 365, float('inf')]
labels = ['0', '1-7', '8-14', '15-30', '31-60', '61-90', '91-180', '181-365', '365+']

approved_df['Support Bin'] = pd.cut(
    approved_df["Days to Support"],
    bins=bins,
    labels=labels,
    right=True  # includes right edge in the bin
)

#Grouping by bins and calculate counts and percentages
bin_counts = approved_df['Support Bin'].value_counts(sort=False)
bin_percentages = (bin_counts / bin_counts.sum() * 100).round(2)

#Creating summary table
summary_table = pd.DataFrame({
    'Count': bin_counts,
    'Percentage (%)': bin_percentages
}).reset_index().rename(columns={'index': 'Days to Support Range'})

summary_table = summary_table.style.format({"Percentage (%)": "{:.1f}%"})

#Displaying summary table in Streamlit
st.title("How many days does providing support take?")
st.subheader("Days to Spend Support: Distribution by Bin")
st.dataframe(summary_table)

# Displaying chart
# Rebuild or access unformatted summary_table if needed
chart_data = pd.DataFrame({
    'Days to Support Range': labels,
    'Count': bin_counts.values,
    'Percentage': bin_percentages.values
})

# Create horizontal bar chart
fig = px.bar(
    chart_data,
    x='Count',
    y='Days to Support Range',
    orientation='h',
    text=chart_data['Percentage'].map(lambda x: f"{x:.1f}%"),
    labels={'Count': 'Number of Cases', 'Days to Support Range': 'Days to Support'},
    title='Distribution of Days to Support (Horizontal Bar)'
)

fig.update_traces(textposition='outside')
fig.update_layout(
    yaxis=dict(categoryorder='total ascending'),
    xaxis_title='Count',
    yaxis_title='Days to Support Range',
    height=500
)

#Displaying chart in Streamlit
st.subheader("Days to Spend Support: Distribution by Bin")
st.plotly_chart(fig)


#Displaying summary statistics in streamlit. Note: The distribution of data in this table corresponds with the counts in each bin
st.subheader("Summary Statistics for 'Days to Support'")
st.dataframe(approved_df["Days to Support"].describe().to_frame())

#Page four: how many patients did not use their full grant amount in a given application year. What are the average amounts given by assistance type?

st.title("Grant Usage by Application Year")

#Using the shared CSV file


# 1. Filter to approved
df_approved = df[df["Request Status"].str.strip().str.lower() == "approved"].copy()

# 2. Drop rows with missing critical data
# Changed "Remaining balance" to the actual column name "Remaining Balance"
usage_df = df_approved.dropna(subset=["App Year", "Remaining Balance"]).copy()

# Convert columns to numeric just in case
usage_df["App Year"] = pd.to_numeric(usage_df["App Year"], errors="coerce")
usage_df["Remaining Balance"] = pd.to_numeric(usage_df["Remaining Balance"], errors="coerce")

# Focus on App Year 1–6
usage_df = usage_df[(usage_df["App Year"] >= 1) & (usage_df["App Year"] <= 6)]

# Create usage status
def grant_status(balance):
    if balance == 0:
        return "Fully Used"
    elif balance < 0:
        return "Overused"
    else:
        return "Remaining"

# Changed "Remaining balance" to the actual column name "Remaining Balance"
usage_df["Grant Usage Status"] = usage_df["Remaining Balance"].apply(grant_status)

# Group by App Year and Usage Status
summary = usage_df.groupby(["App Year", "Grant Usage Status"]).size().unstack(fill_value=0)

# Add total and percentage
summary["Total"] = summary.sum(axis=1)
summary["Fully Used %"] = (summary.get("Fully Used", 0) / summary["Total"] * 100).round(1)
summary["Overused %"] = (summary.get("Overused", 0) / summary["Total"] * 100).round(1)
summary["Remaining %"] = (summary.get("Remaining", 0) / summary["Total"] * 100).round(1)

summary["Fully Used %"] = summary["Fully Used %"].map(lambda x: f"{x:.1f}%")
summary["Overused %"] = summary["Overused %"].map(lambda x: f"{x:.1f}%")
summary["Remaining %"] = summary["Remaining %"].map(lambda x: f"{x:.1f}%")

# Display
st.subheader("Grant Usage Summary by Application Year")
st.dataframe(summary)

# Total usage distribution (across all App Years)
overall_counts = usage_df["Grant Usage Status"].value_counts().reset_index()
overall_counts.columns = ["Grant Usage", "Count"]

# Add percentage column for reference
overall_counts["Percentage"] = (overall_counts["Count"] / overall_counts["Count"].sum() * 100).round(1)

# Pie chart
fig = px.pie(
    overall_counts,
    names="Grant Usage",
    values="Count",
    title="Overall Grant Usage Distribution (Approved Applications)",
    color_discrete_sequence=px.colors.qualitative.Set3,
    hole=0.4  # donut chart style
)

st.plotly_chart(fig)

#identifying average amount by type of assistance

st.subheader("Average Grant Amount by Assistance Type")

# --- Clean "Amount" and "Type of Assistance (CLASS)" ---
df_approved["Amount"] = pd.to_numeric(df_approved["Amount"], errors="coerce")

def clean_assistance_type(value):
    if pd.isna(value):
        return "Missing"
    val = value.strip().lower()
    if "housing" in val:
        return "Housing"
    return val.title()

df_approved["Assistance Type"] = df_approved["Type of Assistance (CLASS)"].apply(clean_assistance_type)

# --- Group by Assistance Type and calculate average ---
avg_amounts = (
    df_approved.groupby("Assistance Type")["Amount"]
    .mean()
    .round(2)
    .sort_values(ascending=False)
    .reset_index()
)

# --- Format dollar amounts for display in chart labels ---
avg_amounts["Amount Label"] = avg_amounts["Amount"].map(lambda x: f"${x:,.2f}")

# --- Plot using Plotly for horizontal, sorted bar chart ---
fig = px.bar(
    avg_amounts,
    x="Amount",
    y="Assistance Type",
    orientation="h",
    text="Amount Label",
    title="Average Grant Amount by Assistance Type (Approved Only)",
    labels={"Amount": "Avg Amount ($)", "Assistance Type": "Assistance Type"},
)

fig.update_traces(textposition="outside")
fig.update_layout(
    yaxis=dict(categoryorder='total ascending'),  # largest at top
    xaxis_tickprefix="$",
    xaxis_title="Average Amount ($)",
    yaxis_title=""
)
# Show table (optional)
st.dataframe(avg_amounts[["Assistance Type", "Amount Label"]].rename(columns={"Amount Label": "Average Amount ($)"}))

# --- Show chart in Streamlit ---
st.plotly_chart(fig, use_container_width=True)

#Page 5: a page that showcases a high-level summary of impact and progress over the past year that can be shown to stakeholders in the foundation.


# ---------- Page Title ----------
st.title("Nebraska Cancer Specialists Hope Foundation: High-level summary")


# ---------- Clean Column Names ----------
df.columns = df.columns.str.strip()

# ---------- Clean 'Type of Assistance (CLASS)' ----------
df['Type of Assistance (CLASS)'] = (
    df['Type of Assistance (CLASS)']
    .astype(str)
    .str.strip()
    .str.title()
    .replace({'None': 'Missing', 'Nan': 'Missing', '': 'Missing'})
)

# ---------- Ensure Amount is Numeric ----------
df['Amount'] = pd.to_numeric(df['Amount'], errors='coerce')

# ---------- Mission Statement ----------
st.subheader("Mission")
st.markdown("""
The NCS HOPE Foundation seeks to improve the lives of individuals and families in the community who are impacted by cancer treatment.
The foundation provides financial assistance, supportive services, and other resources to oncology and hematology patients, families, and caregivers receiving care in Nebraska.
""")

# ---------- Request Status Summary ----------
st.subheader("Request Summary")
status_counts = df['Request Status'].value_counts()
status_percent = (status_counts / len(df)).apply(lambda x: f"{x:.2%}")
summary_df = pd.DataFrame({
    "Count": status_counts,
    "Percentage": status_percent
})
st.dataframe(summary_df)

# ---------- Pie Chart of Request Status ----------
st.subheader("Request Status Distribution (Pie Chart)")
status_counts_df = df['Request Status'].value_counts().reset_index()
status_counts_df.columns = ['Request Status', 'Count']
status_counts_df['Percentage'] = (status_counts_df['Count'] / len(df)).apply(lambda x: f"{x:.2%}")

fig = px.pie(
    status_counts_df,
    names='Request Status',
    values='Count',
    title='Request Status Distribution',
    hole=0.4,
)
fig.update_traces(textinfo='label+percent+value',
                  hovertemplate="%{label}<br>Count: %{value}<br>Percent: %{percent}")
st.plotly_chart(fig)

# ---------- Approved Requests ----------
approved_df = df[df['Request Status'] == 'Approved']

st.subheader("Approved Financial Support Summary")
if not approved_df.empty:
    total_approved_amount = approved_df['Amount'].sum()
    st.metric(label="Total Financial Support Approved", value=f"${total_approved_amount:,.2f}")

    # Distribution by Type of Assistance (CLASS)
    dist_by_class = (
        approved_df.groupby("Type of Assistance (CLASS)")["Amount"]
        .agg(['sum', 'count'])
        .rename(columns={'sum': 'Total Amount', 'count': 'Number of Requests'})
    )
    dist_by_class["Percentage of Total Amount"] = (
        dist_by_class["Total Amount"] / total_approved_amount
    ).apply(lambda x: f"{x:.2%}")
    dist_by_class["Total Amount"] = dist_by_class["Total Amount"].apply(lambda x: f"${x:,.2f}")
    st.dataframe(dist_by_class)

    # Patient Count and Percentage by Assistance Type
    st.subheader("Patient Distribution by Type of Assistance")
    patient_counts = approved_df['Type of Assistance (CLASS)'].value_counts()
    patient_percent = (patient_counts / len(approved_df)).apply(lambda x: f"{x:.2%}")
    patient_summary = pd.DataFrame({
        "Count of Patients": patient_counts,
        "Percentage": patient_percent
    })
    st.dataframe(patient_summary)
else:
    st.info("No approved requests to display.")
